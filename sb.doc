
	1.INTRODUCTION

	This is a package for recording and playing sounds on
	a DOS machine, using djgpp. It uses buffered DMA play,
	so in principle you can do what you like once you
	started playing the sound. In this special version I
	implemented a loop, waiting for a keypress and correctly
	ending playing/recording. Look at the sb_play/sb_rec
	routines. Everything in the 'while(sb_dma_active)' loop
	is not vital and could be removed, including the while
	itself. The calling function then would be responsible
	for making sure if the sound is finished or not.
	Of course, in that case the sb_cleanup_ints must also be
	transferred to that function and be called AFTER all
	playing is finished. You cannot just install the interrupts
	at the start of the program and leave them hanging around,
	as playing and recording use different interrupt routines!
	Hopefully this is finally a stable version, I tested it
	with all kinds of files in several environments and it
	worked flawlessly.
	Improvements or error reports to the following adress :
	kordmann@ldv01.Uni-Trier.de


	2.WHAT'S NEW

	02 : - added high speed DMA to correctly process sampling
	     rates above 37037 Hz
	     - changed memcpy to dosmem... to work under the new
	     dpmi supporting djgpp 1.12
	     - removed handmade getch()/kbhit(), as the library
	     versions meanwhile work flawlessly


	3.SUPPORTED

	The program was written for an 8-bit Soundblaster or
	compatible card. The data is therefore stored in an
	array of unsigned char. 16 or 32 bit or whatever
	samples won't work. Feel free to modify the code if
	you need it, I don't know how to do it.
	As it runs under go32, it allows you to record as much
	sound as fits in your memory. If your machine has 8MB
	and you want to record at 20KHz eg, that would make
	about 5 minutes, depending on memory usage of your
	program, TSRs and the environment.

	4.USAGE

	ATTENTION : due to a bug in go32 1.11, your machine may
	crash when you use these routines. There is a fix for
	this by Grzegorz Jablonski. See patch.txt for it. This
	is fixed in 1.12.

	Before anything else, call sb_init. It will return the
	address of your soundcard if successful, 0 else.
	In most cases, I guess, it will suffice to use the two
	routines SoundPlay and SoundRec, both with the
	parameters  Rate : int, the sampling rate
		    data : unsigned char *, where the sound is
			stored. Must be allocated before calling
			SoundPlay or SoundRec
		    length : unsigned long, length of data in byte
	When you don't need the functions anymore, or before leaving
	the program, call sb_cleanup to free the memory used.

	The included program main.c gives a short example how to
	calculate length and how to call the functions.
	Usage is : main [<filename.wav>] [-r [-f<samplingrate>][-t<time>]]

	filename : if not given defaults to 'test.wav'
	-r : recording mode. Only then the other options are valid
	-f : sampling rate (or frequency) in Hertz (samples per second)
	     defaults to 12000
	-t : recording time in miliseconds, defaults to 2000

	5.FILES

	sb.c : the library routines as such
	sb.h : header file for the library
	main.c : example program for recording and playing .wav files
	wave.c : routines for reading and writing .wav files
	makefile : makes the example program using gcc, executable sound
	patch.txt : contains a bugfix for go32 1.11.maint5

	6.ERRORS

	I did not test it under windows. As this marvellous ;->
	product crashes about everything there might be some kind
	or the other of a problem...

	7. THANKS

	The basic code is mainly from David Baggett, who again based
	it on SoundBlaster Freedom project and linux code. Without
	the bugfixes of Grzegorz Jablonski nothing would have been
	possible, and of course without D.J.Delories port of the
	gcc compiler written by... and so on
