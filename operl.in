
# Copyright (C) 1996 - 2001 Tim Witham <twitham@pcocd2.intel.com>
# Copyright (C) 2015 Brent Baccala <cosine@freesoft.org>

# (see the files README and COPYING for more details)

# xoscope external math filter command example in perl

# !!! Please see bottom of this file for instructions and examples !!!

$| = 1;				# unbuffer stdout
$0 =~ s!.*/!!;			# reduce to program basename
$func = $ENV{FUNC};		# get function to run from environment
$samples = $ARGV[1] || 640;	# assume 640 total samples per screen
$func =~ s/\#.*$//;		# toss comments
$func =~ s/^\s*(\$0\s*=)?\s*//;	# and assumed leading/trailing stuff, if any
$func =~ s/\s*;*\s*$//;
$func =~ s/([\$@])([0-9])/\1d\2/g; # convert $1/$2 to $d1/$d2
die "usage: $0 'perl math function of \$t, \$1 and \$2' [sample length]\n"
    unless $func;		# oops
$func = "\$d0 = $func;";	# '$d0=' and ';' are implied around function

open(IN, '<&3')			# open non-standard input for reading
    || die "$0: Can't read input: $!\n";
open(OUT, '>-')			# and stdout for writing
    || die "$0: Can't write stdout: $!\n";

$pi = 3.14159265359;		# define pi for user's convenience
$t = 0;				# sample position number (time)
for (1..$samples) {		# initialize sample memory "shift registers"
    push(@d1, 0);		# channel 1 (left)
    push(@d2, 0);		# channel 2 (right)
    push(@d0, 0);		# output back to software channel
}

# For efficiency, we now dynamically build a while loop around the
# user's function then evaluate (compile and run) it once.

# begin of loop: how to read the samples (two shorts) from stdin:
$begin = '
while(1) {
    sysread(IN, $buff, 2) || exit;
    $d1 = unpack(\'s\', $buff);
    sysread(IN, $buff, 2) || exit;
    $d2 = unpack(\'s\', $buff);

';

# end: how to increment time, remember the samples, and write result to stdout:
$end = '

    $t = 0 if ++$t >= $samples;';

# sample history is expensive, so we only remember those the function needs:
$end .= '
    pop(@d1); unshift(@d1, $d1);' if $func =~ /\$d1\[/;
$end .= '
    pop(@d2); unshift(@d2, $d2);' if $func =~ /\$d2\[/;
$end .= '
    pop(@d0); unshift(@d0, $d0);' if $func =~ /\$d0\[/;

$end .= '
    syswrite(OUT, pack(\'s\', $d0), 2) || exit;
}
';

# now put the loop around the user's function
eval $begin.$func.$end;		# and finally run the loop forever
warn "$@\n" if $@;		# show any user syntax errors on stderr

__END__
{}
# !!!!!!!!!!		INSTRUCTIONS and EXAMPLES		!!!!!!!!!!

# This is an example x*oscope external math filter command in perl

# usage: operl 'math' [samples]

# First argument is arbitrary signal math to do!  Be sure to quote the
# math function from the shell, single-quotes are best.  Variables
# available for your function:

# $1	channel 1 input
# $2	channel 2 input
# $0	output: '$0 = ' is assumed before your function; don't use $0
# @1	channel 1 "memory", $1[0] = previous sample, $1[1] = one before that...
# @2	channel 2 "memory",         ... all the way to sample length or $1[639]
# @0	output "memory", $0[0] = previous function output calculation, ...
# $t	sample number, or "time", 0=left edge or trigger point
# $pi	a constant: 3.14159265359, for your trigonometric convenience

# Second command-line argument is the number of samples per screenful.
# You may need to use this if you resize the window.  (default = 640)

# example command-line argument functions, the ';' is optional:

# functions of one of the input channels (would also work for $2):
abs($1);			# rectify (absolute value)
~$1;				# negate (invert)
$1 - $1[0];			# integral or rate of change since last sample
$1 - $1[2];			# same but over more time (3 sample periods)
$1 + 32;			# add a "DC offset" of 32 sample units
$t > 43 ? $1[43] : 0;		# delay by 1 msec @ 44000 S/s = 44th sample

# functions of both channel 1 and channel 2:
$1 * $2;			# multiply 1 * 2
$1 / ($2 || 1);			# divide 1 / 2, avoiding divide by 0 error
$2 / ($1 || 1);			# divide 2 / 1
$1 > $2 ? $1 : $2;		# max(1, 2)
$1 < $2 ? $1 : $2;		# min(1, 2)
$1 + $2;			# sum, like the oscope builtin
$1 - $2;			# diff, like the oscope builtin
($1 + $2) / 2;			# average, like the oscope builtin

# time position ($t) functions, independent of $1 and $2 inputs:
$t / 88 % 2 ? 64 : -64;		#  250 Hz square wave (88 = 44000 / 2 /  250)
sin($t * $pi / 44) * 64;	#  500 Hz    sin wave (44 = 44000 / 2 /  500)
cos($t * $pi / 22) * 64;	# 1000 Hz cosine wave (22 = 44000 / 2 / 1000)

# low-pass filter: a difference equation of previous input and output:
1.899105 * $0[0] - .901531 * $0[1] + .001213 * ($1 + $1[1] + 2 * $1[0]);

# operl ends here.
